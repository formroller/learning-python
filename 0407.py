# =============================================================================
# 3장 실습. IDE (저장, F5 => 전체 실행)
# =============================================================================
money = int(input('지폐로 교환할 돈은 얼마? ' ))

q50 = money//50000 # 몫(%/% in R)
money = money % 50000 # 나머지 (%% in R)

q10 = money//10000
money = money % 10000

q5 = money//5000
money = money % 5000

q1 = money //1000
money = money % 1000

print('50000원짜리 => %2d장' % q50)
print('10000원짜리 => %2d장' % q10)
print('5000원짜리 =>  %2d장' % q5)
print('1000원짜리 =>  %2d장' % q1)
print('지폐로 바꾸지 못하 돈 => $d장' %money)


v1 = int(input('교환할 돈, '))
v1%50000
v1//50000
v2 =int( v1 // 50000)
v3 = int((v1 % 50000)//10000)
v4 = (v1%50000%10000) //5000
v5=(v1%50000%10000%5000)//1000 
v6=(v1%50000%10000%5000%1000)
print('50000원짜리 ==> %d장' % v2)
print('10000원짜리 ==> %d장' % v3)
print('5000원짜리 ==> %d장' % v4)
print('1000원짜리 ==> %d장' % v5)
print('지폐로 바꾸지 못한 돈 ==> %d원' % v6)
# =============================================================================
# 
# =============================================================================

# 논리연산자
v1 = 10
(v1 >5) & (v1 < 15)
(v1 >5) and (v1 < 15)

(v1 >5) | (v1 < 15)
(v1 >5) or (v1 < 15)

!(v1 >5)     # R에서의 부정 연산자
not (v1 >5)  # 파이썬 부정 연산자 (pandas에서의 부정 ~ ) 

# 리스트 
# - R에서 벡터와 유사.
# - 여러개의 값을 하나로 묶기 위한 최소 단위 자료구조
# - 1차원 형식
#  (차이점)
# - 중첩구조 가능(리스트 內 리스트 삽입 가능)
# - 서로 다른 데이터 타입 입력 가능
 
#1. 생성
L1 = [1,2,3]
L2 = [1,'2',3] ;L2     # 서로 다른 데이터 타입 입력 가능(벡터와 다르다)
L3 = [1,2,[3,4]] ; L3  # 중첩 가능
L4 = [1,2,3,4,5,6]
L5 = [[1,2],[3,4]]
sum(L5, [])
sum([[1,2],[3,4]],[])
#2. 색인
L1[0]     # 정수(position) 색인 가능

L1[0:2]   # 슬라이스 색인 (0부터 1까지 출력)
L1[1:]    # 슬라이스 색인 - 끝까지
L1[:3]    # 슬라이스 색인 - 처음부터

L1[[0,2]] # 리스트 묶어서(전달한) 색인 불가 (정수값 or 연속적인 범위만 색인 가능)
          # 동시에 여래개 전달 불가
L3[2][0]
L1[-1]    # (-)값은 역순으로 출력 -> reverse indexing

L4[::2]  # start : end : by / 처음부터 끝까지 2씩 더한값 



#3. 수정
L1[0] = 10; L1
L1[1] = [20,30]; L1 # 중첩 리스트로 생성된다.(선택원소 1개, 넣을 값 多)
L1[1:3] = [20,30]; L1

#4. 확장
# - 벡터안에 벡터넣기
L1.append(40); L1
L1[4] # 범위를 넘어선 값 입력 불가(out of range)
      # => 새로운 위치에 값 할당 불가
      
L1 = [1,2,3]      
L2 = [4,5,6]

L1 + L2        # 리스트 확장
L1 * 3         # 리스트의 확장(3번 반복)
L1 = L1 + [4]  # 리스트 원소 추가

L1.extend([5]) # [추가원소] 즉시 반영

# (참고 in R)==================================================================
# #v1 <- c(1,2,3)
# #v1 <- c(v1,4)
# #v1 <- append(v1,4)
# #v1[4] <- 4 없을때 in R =>NULL
# =============================================================================


#5. 삭제
del(L1[3])   # 원소의 삭제
del(L1[0])   # 중간위치 원소 삭제 가능 (R에서는 불가)
del(L1) ; L1 # 객체 전체 삭제 (rm과 같은 기능, rm(list='L1')) (=drop)
L2 = []      # 객체 원소 삭제 (=truncate)


# lambda
# - 사용자 정의 함수(축약형)
# 장) 간단함
# 단) 오로지 리턴(복잡한 조건,반복 처리 불가- if/for문 불가)


#1) 기존 함수 선언 방식
def 함수명 :

#2) lambda
lambda input : output


#예제) 입력된 값의 10% 증가값을 리턴하는 함수 생성
f1 = lambda x : x + 1.1    
f1(10)

#예제) 두 수를 입력받아 두 수의 합 리턴
f2 = lambda x , y=0 : x+y  # 인자의 기본값 선언 가능
f2 = lambda x=0 , y : x+y  # 앞의 인자에 기본값 지정하면 뒤에 오는 인자도 기본값 지정해야한다

f2(1,10)
f2(12)

# 리스트의 벡터연산(적용함수)
L1 + 1    # 벡터연산(각 원소의 반복적용) 불가
L1 + 1.1  # 벡터연산(각 원소의 반복적용) 불가

#예제) L1의 각 원소에 10% 인상된 값 연산
f1(L1)           # 불가
map(f1,L1)       # 가능 (map함수에 의한 반복적용)
list(map(f1,L1)) 
#=> 사용자가 출력 형식 지정하지 않으면 메모리에 저장만 한다.=> 리스트에 담아야한다.
#=> 매핑처리는 map함수 통해 각 원소별 반복 적용 (=sapply in R)

예제)L1 + L11의 결과 리턴
L11=[1,2,3,4]       
L1 + L11             # 불가, 리스트 + 리스트 => 리스트 간 결합(리스트의 확장)
list(map(f2,L1,L11)) # 가능
# => mapply와 같은 형식

map? # help
#*args, * 여러인자 전달 가능
#**kwargs, ** key values 형식으로 전달

#연습문제)
다음의 리스트를 생성
L1 = [1,2,3,4]
L2 = [10,20,30,40]
L3 = [100,200,300]
L4 = ['서울','부산','대전','전주']
L5 = ['abc@naver.com','a123@hanmail.net']

#1. L2의 L1승 출력, 10^1, 20^2
t1 = lambda x , y : x**y
list(map(t1,L2,L1))        # 함수 만들고 매핑처리

#2. L4의 값에 '시'를 붙여 출력
L4 + '시' # 불가
f2 = lambda x : x + '시'
list(map(f2,L4))

t2 = lambda x,y='시' : x+y
list(map(t2,L4))

#3. L5에서 이메일 아이디만 출력
t3 = lambda x : x.split('@')[0]
list(map(t3,L5))

# =============================================================================
# [참고] map, R에서의 적용함수 
# sapply(L1,f1)
# mapply(f1,L1)
# 
# sapply(L1,f1,L2)
# mapply(f1,L1,L2)  # 함수, 인자, 인자
# =============================================================================

# 2차원 형식 리스트
L1 = [[1,2,3],[4,5,6],[7,8,9]]
len(L1) # L1의 객체 -> 3개 (묶음별)

L1[1][0]


























